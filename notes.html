 <html>
<marquee>COMP SCI NOTES</marquee>
<center><b>system.out.printf()</b>
            <ul>-prints on the same line</ul>
	    <ul>-placeholders: %s (string) %d(int) %f(floting point number)</ul>
	    <ul>-%n_s/d/f leaves n number of spaces for each string/int/float</ul>



  <br><b>mergesort(a.k.a. the stuyvesant way)</b>
         <ul>-sorts recursively</ul>
	 <ul>-breaks apart the given set to sort and then merge</ul>



  <b>merge sort:</b>2nlogN (aka nlogN)
  <ul>-splits/levels logBASE2(1)</ul>
  <ul>-each split loops thru array: n</ul>
  <ul>-each levels of merge: n</ul>
  <b>linear search:</b> n
  <br><b>binary search:</b> logN

<br><b>Big O notation</b> (order notation)
   <br>function f(n) is said to be O(g(n)) [order g(n) or Big O g(n) ]
   <br>if there exists some constant k such that K(g(n))> f(n) and the 
   <br>long term.
   <br>tight upper bound
 <br>
<br><b>Select</b>
<ul> Choose a pivot value</ul>
<ul> partition the list</ul>
<ul>repeat for the right list partition</ul> 

<br><b>Linked List</b>
<ul> node: contains some data information on how to get to the next node</ul>
<ul> a set of nodes and a way to get to the start node</ul>
<ul> a circular type of list</ul>

<br><b>Last in First Out</b> (LIFO)
<br> Stacks:
<br> Allows recursion to happen, give computuer last function done.
<br> example in the real world: 
<br>when you take from the middle of a pile and place it back on top
<br><b>	METHODS</b>
<ul>Push(s) puts s on top of the stack</ul>
<ul>pop() remove item from the top of the stack and returns it</ul>
<br>Sometimes used
<ul>empty() returns true or false</ul>
<ul>peek()returns but doesnt remove the top element in the stack</ul>

<br>First in First Out (FIFO)
<br><b>Queue</b>
<br>Queue q = new Queue()
<ul>q.enqueue(x) : add x to the back or tail of the queue</ul>
<ul>x=q.dequeue() : remove and return the item @ the head of the queue</ul>
<br>
<ul>.empty(), .front(), .head()</ul>
<ul> .size()
<br>
<br><b>Maze Solver</b>
<br> 2D Array of chars
<br>Depth first search:goes alllllll the way till dead end 
<br>Breath first search:searches in a "radius"
<br>put start node on frontier (enqueue) and mark as visited
<br>for each unvisited neighbor of n, ().enqueue it to frontier
<br>
<br><b>BEST FIRST SEARCH (Priority Queue)</b>
<ul>each time you check a Node, you check it's priority, then add it in order of decreasing priority.</ul>
<ul> When adding to the frontier, first must be assigned a priority, and then added</ul>
<br><b>Maze Herristics:</b>
<ul> distance formula (euclidean)</ul>
<ul> manhattan (taxi cab) distance (abs(diff in x)+abs(diff in y))</ul>
</center>
<br>
<br><b>Trees:</b>
<ul> <b>Graph:</b> a collection of nodes and edges (vertices)</ul> 
<ul> node---> holds stuff</ul>
<ul> edge: connects nodes</ul>
Root

Child 

Parent

Leaf---> node w/ no children

Siblings---> from the same parent

Ancestors---> any node on the path from n to the root

Descendants--->children, their children etc.
</html>
 
 
